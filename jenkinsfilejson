pipeline {
    agent any

    parameters {
        string(name: 'APP_ID', defaultValue: '', description: 'ID de la aplicación a consultar (INT)')
    }

    environment {
        DB_USER = 'almDevopsAdmin'
        DB_NAME = 'almdevops'
        DB_HOST = 'localhost'
        OUTPUT_FILE = 'app_properties_output.json'
    }

    stages {
        stage('Detectar tipo de aplicación') {
            steps {
                script {
                    def tipoApp = sh(
                        script: """
                            psql -U $DB_USER -h $DB_HOST -d $DB_NAME -t -c "
                                SELECT
                                    CASE
                                        WHEN id_microservice_directory IS NOT NULL THEN 'microservice'
                                        WHEN id_was_properties_directory IS NOT NULL THEN 'was'
                                        WHEN id_pims_properties_directory IS NOT NULL THEN 'pims'
                                        WHEN id_database_properties_directory IS NOT NULL THEN 'ddbb'
                                        WHEN id_datastage_properties_directory IS NOT NULL THEN 'datastage'
                                        ELSE 'desconocido'
                                    END AS app_type
                                FROM app_general_properties
                                WHERE id = ${params.APP_ID}
                            "
                        """,
                        returnStdout: true
                    ).trim()

                    echo "Tipo de aplicación detectado: ${tipoApp}"
                    env.APP_TYPE = tipoApp
                }
            }
        }

        stage('Exportar a JSON con wrapper') {
            steps {
                script {
                    def functionQuery = ""

                    if (env.APP_TYPE == "microservice") {
                        functionQuery = "SELECT row_to_json(t) FROM get_microservice_app_properties(${params.APP_ID}) AS t;"
                    } else if (env.APP_TYPE == "was") {
                        functionQuery = "SELECT row_to_json(t) FROM get_was_app_properties(${params.APP_ID}) AS t;"
                    } else if (env.APP_TYPE == "pims") {
                        functionQuery = "SELECT row_to_json(t) FROM get_pims_app_properties(${params.APP_ID}) AS t;"
                    } else if (env.APP_TYPE == "ddbb") {
                        functionQuery = "SELECT row_to_json(t) FROM get_database_app_properties(${params.APP_ID}) AS t;"
                    } else if (env.APP_TYPE == "datastage") {
                        functionQuery = "SELECT row_to_json(t) FROM get_datastage_app_properties(${params.APP_ID}) AS t;"
                    } else {
                        error "Tipo de aplicación no soportado o ID inválido."
                    }

                    // Ejecuta la consulta y envuelve el resultado en el formato solicitado
                    sh """
                        APP_RESULT=\$(psql -U $DB_USER -h $DB_HOST -d $DB_NAME -t -A -c "${functionQuery}" | grep -v '^$')
                        # Quita espacios y salto de línea si hay varios registros, los pone como array
                        if [[ "\$APP_RESULT" =~ ^\\{.*\\}$ ]]; then
                            # Si es un solo objeto, lo envolvemos en un array
                            APP_RESULT="[\$APP_RESULT]"
                        fi
                        echo "{ \\"${params.APP_ID}\\": \$APP_RESULT }" > ${env.OUTPUT_FILE}
                    """

                    echo "JSON generado: ${env.OUTPUT_FILE}"
                }
            }
        }

        stage('Leer y asignar variables desde JSON') {
            steps {
                script {
                    def jsonText = readFile("${env.OUTPUT_FILE}").trim()
                    def json = readJSON text: jsonText

                    def fields = []
                    def item = json["${params.APP_ID}"][0]
                    if (item != null) {
                        fields = item.keySet().join(",")
                        env.JSON_FIELDS = fields

                        // Asignar variables de ambiente
                        item.each { k, v ->
                            def varName = k.trim().replaceAll("[^a-zA-Z0-9_]", "_")
                            env."${varName}" = v.toString()
                        }
                    } else {
                        env.JSON_FIELDS = ""
                    }
                }
            }
        }

        stage('Imprimir variables') {
            steps {
                script {
                    def fields = env.JSON_FIELDS ? env.JSON_FIELDS.split(",") : []

                    for (def f : fields) {
                        def cleanName = f.trim().replaceAll("[^a-zA-Z0-9_]", "_")
                        echo "${cleanName} = ${env[cleanName]}"
                    }
                }
            }
        }
    }

    post {
        success {
            archiveArtifacts artifacts: "${env.OUTPUT_FILE}", fingerprint: true
        }
    }
}
